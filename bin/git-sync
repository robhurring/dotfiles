#!/usr/bin/env sh

colorize() {
  printf "\033[${1}m${2}\033[0m\n" "${@:3}"
}

error() {
  colorize "1;31" "$@"
}

success() {
 colorize "1;32" "$@"
}

quiet() {
  colorize "1;30" "$@"
}

note() {
  colorize "33" "$@"
}

in_current_dir() {
  local wd="$(pwd)"
  if [[ "$wd" == $cwd ]]; then
    cwd="$wd"
    return 0
  else
    cwd="$wd"
    return 1
  fi
}

debug_print() {
  local debug=$1
  local message=$2
  if [[ $debug == "debug" ]]; then
    echo $message
  fi
}

dot_git() {
  if in_current_dir && [[ -n "$dot_git" ]]; then
    # cache dot_git to save calls to rev-parse
    printf '%s' $dot_git
  elif [ -d .git ]; then
    dot_git=".git"
    printf '%s' $dot_git
  else
    dot_git="$(git rev-parse --git-dir 2>/dev/null)"
    printf '%s' $dot_git
  fi
}

is_repo() {
  if [[ -n "$(dot_git)" ]]; then
    return 0
  else
    return 1
  fi
}

git_root() {
  if [ -d .git ]; then
    printf '%s' "$(pwd)"
  else
    printf '%s' "$(git rev-parse --show-toplevel 2>/dev/null)"
  fi
}

branch_name() {
  name="$(git symbolic-ref --short HEAD 2>/dev/null)"
  retcode="$?"
  if [[ "$retcode" == "0" ]]; then
    printf %s "$name"
  else
    return 1
  fi
}

commit_short_sha() {
  if is_repo; then
    printf '%s' "$(git rev-parse --short HEAD 2>/dev/null)"
  fi
}

tracking_remote() {
  if branch_name=$(branch_name); then
    local config_key="branch.${branch_name}.remote"
    local remote=$(git config ${config_key} 2>/dev/null)

    if [[ $remote ]]; then
      printf '%s' $remote
      return 0
    else
      return 1
    fi
  else
    return 1
  fi
}

tracking_branch() {
  local localRef="$(tracking_remote)\/$(branch_name)$"

  if [[ -n "$localRef" ]]; then
    local remoteBranch="$(git for-each-ref --format='%(upstream:short)' refs/heads $localRef 2>/dev/null | grep $localRef)"
    if [[ -n $remoteBranch ]]; then
      printf '%s' $remoteBranch
      return 0
    else
      return 1
    fi
  fi
}

commits_behind_of_remote() {
  remote_branch=${1:-"$(tracking_branch)"}
  if [[ -n "$remote_branch" ]]; then
    git rev-list --left-only --count ${remote_branch}...HEAD
  else
    printf '%s' "0"
  fi
}

commits_ahead_of_remote() {
  remote_branch=${1:-"$(tracking_branch)"}
  if [[ -n "$remote_branch" ]]; then
    git rev-list --right-only --count ${remote_branch}...HEAD
  else
    printf '%s' "0"
  fi
}

is_dirty() {
  if ! git rev-parse &> /dev/null; then
    #not in repo, thus not dirty
    return 1
  else
    #in repo, might be dirty
    if [[ -n "$(git ls-files --exclude-standard --others 2>/dev/null)" ]]; then
      #untracked files thus dirty
      return 0
    else
      #no untracked files
      if git show HEAD -- &> /dev/null; then
        #has a commit hash, thus not on an initial commit
        if ! git diff --quiet --ignore-submodules HEAD -- &> /dev/null; then
          #has differences thus dirty
          return 0
        else
          return 1
        fi
      else
        #no commit hash, thus can't use HEAD.
        #As it's inital commit we can just list the files.
        if [[ -n "$(ls -a -1 "$(git_root)" | grep -Ev '(\.|\.\.|\.git)')" ]]; then
          #files listed and no commit hash, thus changes
          return 0
        else
          return 1
        fi
      fi
    fi
  fi
}

run() {
  local cmd="$*"
  colorize "1;30" "$ \e[0;37m%s" "$cmd"
  eval $cmd
}

do_update() {
  local kind=$1
  local upstream=$2
  local start_sha=$(commit_short_sha)
  local stashed=0
  local cmd

  if is_dirty; then
    error "Working directory dirty. Please stash before continuing"
    exit 1
  fi

  if [[ "$kind" == "rebase" ]]; then
    run "git rebase --preserve-merges ${upstream}"
  elif [[ "$kind" == "merge" ]]; then
    run "git merge --ff-only ${upstream}"
  else
    error "Unknown update type '%s'" $kind
    exit 1
  fi

  quiet "HEAD moved from '%s' to '%s'" $start_sha $(commit_short_sha)
}

do_fetch() {
  run "git fetch $1 --quiet"
}

do_sync() {
  local remote="origin"
  local branch=$(branch_name)
  local upstream

  if tracking_remote="$(tracking_remote)"; then
    remote=$tracking_remote
  else
    quiet "No remote found for '%s' assuming 'origin'" $(branch_name)
  fi

  if tracking_branch="$(tracking_branch)"; then
    branch=$tracking_branch
    upstream=$tracking_branch
  else
    quiet "No tracking branch configured, assuming '%s'" $(branch_name)
    upstream="${remote}/${branch}"
  fi

  do_fetch $remote
  note "Against upstream '%s'" $upstream

  ahead="$(commits_ahead_of_remote "$upstream")"
  behind="$(commits_behind_of_remote "$upstream")"

  if [[ "$behind" -gt "0" && "$ahead" -gt "0" ]]; then
    success "Both local and remote branches have moved on. Branch '%s' needs to be rebased onto '%s'" $(branch_name) $upstream
    do_update "rebase" $upstream
  elif [[ "$behind" -gt "0" ]]; then
    success "Local branch '%s' has not moved on. Fast-forwarding..." $(branch_name)
    note "There are %d new commits on '%s'." $behind $upstream
    do_update "merge" $upstream
  elif [[ "$ahead" -gt "0" ]]; then
    note "You have %d new commits on '%s'." $ahead $upstream
  else
    success "Already up-to-date"
  fi

  git-cleanup
}

do_sync
